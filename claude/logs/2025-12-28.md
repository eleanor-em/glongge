# 2025-12-28: Buffer Device Addresses & Materials Sync

## Overview

Major refactoring of the materials buffer system to use Vulkan Buffer Device Addresses (BDA) and fix synchronization issues across multiple frames in flight.

## Commits

- `4f2b26f` [Experimental] Use buffer device addresses (BDA) for materials upload.
- `ccab267` [Experimental] Shader noodling.
- `b2775f1` [Experimental] Maybe fix rounding on Intel iGPUs.
- `610d366` Add fence waiting statistics for frames-in-flight.
- `1e28305` [Experimental] Add explicit out-of-band materials upload flow.

## CLAUDE.md

Created project documentation file with:
- Build instructions
- Architecture overview (core modules, key patterns, procedural macros)
- Configuration constants
- Platform notes: development is on macOS/MoltenVK but targeting all platforms (Windows, Linux, macOS with NVIDIA, AMD, Intel, iGPUs). Code should not assume coherent memory or discrete GPU.

## Buffer Device Addresses (BDA)

Replaced descriptor-bound materials storage buffer with BDA:
- Materials buffer address passed via push constants instead of descriptor binding
- Simplified descriptor set layout (removed storage buffer binding)
- Shaders use `GL_EXT_buffer_reference` to access materials via pointer

## Materials Buffer Synchronization Fix

### Problem
The materials device buffer was single-copy but used across multiple frames in flight - race condition where previous frames could still be reading while new frame writes.

### Solution

**Multi-buffered device buffer:**
- Device buffer now has `FRAMES_IN_FLIGHT` copies (one per frame)
- Staging buffer has `FRAMES_IN_FLIGHT + 1` copies (extra for out-of-band uploads)
- Added `OUT_OF_BAND_FRAME_INDEX` constant for uploads outside frame loop

**Countdown mechanism:**
- Changed `materials_changed: bool` to `materials_upload_countdown: usize`
- When materials change, set countdown to `FRAMES_IN_FLIGHT`
- Each frame copies from staging to its device buffer and decrements
- After N frames, all device buffers have the new data

**Tracking staged data:**
- Added `last_staged_buffer_index: Option<usize>` to track which staging buffer holds current data
- Subsequent frames copy from this buffer to their respective device buffers

**Out-of-band uploads:**
- Renamed `upload_all_pending()` to `upload_all_pending_out_of_band()`
- Out-of-band uploads (init, async texture loading) stage but don't copy immediately
- Subsequent frame renders handle the copy via countdown

**Memory coherence:**
- Added `flush_allocation()` after staging buffer writes for non-coherent memory platforms (Intel, some AMD)

## Fence Statistics

Added statistics collection for fence waiting in swapchain to help diagnose frames-in-flight sync issues.

## Intel iGPU Fixes

- Shader adjustments for Intel compatibility
- UV rounding fixes to avoid texture sampling artifacts

## Sound Library Migration: fyrox-sound → rodio

Replaced fyrox-sound with rodio to reduce dependencies.

### Motivation

`fyrox-sound` pulled in heavy dependencies unnecessary for basic 2D audio:
- `futures` (async runtime)
- `notify` (filesystem watcher)
- `nalgebra` (full linear algebra library)
- `uuid`, `base64`, etc.

### Results

- **Dependencies: 353 → 283** (70 fewer crates)
- Removed duplicate `rand` versions (0.8 vs 0.9)
- Removed `syn` 1.0 duplicate (fyrox-core-derive used old darling)

### API Mapping

| fyrox-sound | rodio |
|-------------|-------|
| `SoundEngine` + `SoundContext` | `OutputStreamBuilder` + `Mixer` |
| `SoundBufferResource` | `SamplesBuffer` |
| `Handle<SoundSource>` | `Sink` |
| `source.set_pitch()` | `source.speed()` |
| `source.set_looping(true)` | `source.repeat_infinite()` |
| `source.status() == Playing` | `!sink.empty()` |

### macOS CoreAudio Limitation

`OutputStream` is not `Send` on macOS due to CoreAudio internals. Solution:
- Use `OnceLock<bool>` to ensure single initialization
- Leak the `OutputStream` via `Box::leak()` to keep it alive
- Only store the `Mixer` (which is `Send`) in `SoundHandler`

### Architecture

```
SoundHandler
├── mixer: Arc<Mixer>           # Cloneable, used to create sinks
├── inner: Arc<Mutex<...>>      # Cache of decoded audio
└── join_handles: ...           # Background loading

SoundHandlerInner
└── loaded_files: BTreeMap<String, SamplesBuffer>  # Decoded PCM cache

Sound
├── inner: Option<Arc<SoundInner>>
└── is_looping: bool

SoundInner
├── buffer: SamplesBuffer       # Cloneable decoded audio
└── sink: Sink                  # Playback handle
```

Each `play()` call clones the `SamplesBuffer` and appends to the sink.
