# 2026-01-10: Fix `GenericCollider::transformed()` and Test Coverage

## Summary

Added tests for a new `GenericCollider::transformed()` method and fixed two bugs discovered during testing.

## Changes

### New Tests for `transformed()`

Added 4 tests to cover the `transformed()` method on `GenericCollider`:

1. `generic_collider_transformed_box_no_rotation` - BoxCollider with scale and translation, no rotation
2. `generic_collider_transformed_box_with_rotation` - BoxCollider with scale, rotation, and translation (becomes OrientedBox)
3. `generic_collider_transformed_non_box` - ConvexCollider with scale, rotation, and translation
4. `generic_collider_transformed_oriented_box_canceling_rotation` - OrientedBox where rotation cancels out, converting back to Box

### Bug Fix 1: `OrientedBoxCollider::translated()` rotating translation vector

**Location:** `src/util/collision.rs:562-566`

**Problem:** The `translated()` method was rotating the translation vector by the box's own rotation before applying it:
```rust
// Before (incorrect)
fn translated(&self, by: Vec2) -> Self {
    let mut rv = self.clone();
    rv.centre += by.rotated(self.rotation);
    rv
}
```

This caused translations to be applied in "local" coordinates rather than world coordinates, which was counterintuitive and caused issues in `transformed()`.

**Fix:** Translation now applies directly without rotation:
```rust
// After (correct)
fn translated(&self, by: Vec2) -> Self {
    let mut rv = self.clone();
    rv.centre += by;
    rv
}
```

### Bug Fix 2: `GenericCollider::transformed()` not applying scale/translate in OrientedBox branch

**Location:** `src/util/collision.rs:1757-1776`

**Problem:** The branch handling OrientedBox with canceling rotation was only converting to BoxCollider without applying scale or translation:
```rust
// Before (incorrect)
} else if let GenericCollider::OrientedBox(c) = self
    && c.rotation + by.rotation == 0.0
{
    BoxCollider::from_aa_extent(c).as_generic()
}
```

**Fix:** All branches now properly translate to origin, scale, rotate (if applicable), then translate to final position:
```rust
// After (correct)
let original_centre = self.centre();
if self.get_type() == ColliderType::Box && by.rotation == 0.0 {
    self.translated(-original_centre)
        .scaled(by.scale)
        .translated(original_centre + by.centre)
} else if let GenericCollider::OrientedBox(c) = self
    && c.rotation + by.rotation == 0.0
{
    BoxCollider::from_aa_extent(c)
        .translated(-original_centre)
        .scaled(by.scale)
        .translated(original_centre + by.centre)
        .as_generic()
} else {
    self.translated(-original_centre)
        .scaled(by.scale)
        .rotated(by.rotation)
        .translated(original_centre + by.centre)
}
```

This ensures that:
- Scale and rotation happen around the collider's own centre (not the origin)
- The final centre is `original_centre + transform.centre`

### Other Changes

- Added `use std::f32::consts::SQRT_2;` import to test module
- Replaced `std::f32::consts::SQRT_2` with `SQRT_2` throughout tests
- Updated `oriented_box_translation` test to reflect corrected behaviour
- Removed obsolete TODO comment about counterintuitive translation behaviour

## Verification

- All 375 tests pass
- Clippy passes with pedantic lints
- 100% code coverage maintained for:
  - `util/collision.rs`
  - `util/colour.rs`
  - `util/linalg.rs`
  - `util/spline.rs`
  - `resource/rich_text.rs`
